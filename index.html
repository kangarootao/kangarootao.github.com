<!doctype html>



  


<html class="theme-next pisces use-motion">
<head>
  <meta charset="UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"/>



<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />












  
  
  <link href="/vendors/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css" />




  
  
  
  

  
    
    
  

  

  

  

  

  
    
    
    <link href="//fonts.googleapis.com/css?family=Lato:300,300italic,400,400italic,700,700italic&subset=latin,latin-ext" rel="stylesheet" type="text/css">
  






<link href="/vendors/font-awesome/css/font-awesome.min.css?v=4.4.0" rel="stylesheet" type="text/css" />

<link href="/css/main.css?v=5.0.1" rel="stylesheet" type="text/css" />


  <meta name="keywords" content="Hexo, NexT" />








  <link rel="shortcut icon" type="image/x-icon" href="/favicon.ico?v=5.0.1" />






<meta property="og:type" content="website">
<meta property="og:title" content="Kangarootao的主页">
<meta property="og:url" content="http://kangarootao.github.io/index.html">
<meta property="og:site_name" content="Kangarootao的主页">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="Kangarootao的主页">



<script type="text/javascript" id="hexo.configuration">
  var NexT = window.NexT || {};
  var CONFIG = {
    scheme: 'Pisces',
    sidebar: {"position":"left","display":"post"},
    fancybox: true,
    motion: true,
    duoshuo: {
      userId: 0,
      author: '博主'
    }
  };
</script>

  <title> Kangarootao的主页 </title>
</head>

<body itemscope itemtype="http://schema.org/WebPage" lang="zh-Hans">

  










  
  
    
  

  <div class="container one-collumn sidebar-position-left 
   page-home 
 ">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-meta ">
  

  <div class="custom-logo-site-title">
    <a href="/"  class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <span class="site-title">Kangarootao的主页</span>
      <span class="logo-line-after"><i></i></span>
    </a>
  </div>
  <p class="site-subtitle"></p>
</div>

<div class="site-nav-toggle">
  <button>
    <span class="btn-bar"></span>
    <span class="btn-bar"></span>
    <span class="btn-bar"></span>
  </button>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-home">
          <a href="/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-home"></i> <br />
            
            首页
          </a>
        </li>
      
        
        <li class="menu-item menu-item-categories">
          <a href="/categories" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-th"></i> <br />
            
            分类
          </a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="/archives" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-archive"></i> <br />
            
            归档
          </a>
        </li>
      
        
        <li class="menu-item menu-item-tags">
          <a href="/tags" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-tags"></i> <br />
            
            标签
          </a>
        </li>
      

      
    </ul>
  

  
</nav>

 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            
  <section id="posts" class="posts-expand">
    
      

  
  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2017/07/18/项目/VR校园坦克大战/" itemprop="url">
                  VR校园坦克大战
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            <span class="post-meta-item-icon">
              <i class="fa fa-calendar-o"></i>
            </span>
            <span class="post-meta-item-text">发表于</span>
            <time itemprop="dateCreated" datetime="2017-07-18T22:34:23+08:00" content="2017-07-18">
              2017-07-18
            </time>
          </span>

          
            <span class="post-category" >
              &nbsp; | &nbsp;
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
              
                <span itemprop="about" itemscope itemtype="https://schema.org/Thing">
                  <a href="/categories/项目经历/" itemprop="url" rel="index">
                    <span itemprop="name">项目经历</span>
                  </a>
                </span>

                
                

              
            </span>
          

          
            
              <span class="post-comments-count">
                &nbsp; | &nbsp;
                <a href="/2017/07/18/项目/VR校园坦克大战/#comments" itemprop="discussionUrl">
                  <span class="post-comments-count ds-thread-count" data-thread-key="2017/07/18/项目/VR校园坦克大战/" itemprop="commentsCount"></span>
                </a>
              </span>
            
          

          

          
          

          
        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>项目开展时间为2015年4月至5月，基于Oculus rift DK2设备，通过Unity3D制作的VR游戏Demo。本人负责游戏设计，整合素材和逻辑实现。素材来源为同学制作的交大电院大草坪附近场景模型，素材网上的部分人物模型以及游戏坦克世界里IS-3，虎式，鼠式模型，并自己制作了履带以及转动动画。游戏背景为电院和机动学院将要在电院大草坪举行坦克大战，第一阶段玩家作为学生可以在校园中四处行走，与场地附近的人物交谈，通过头盔调整视角，通过键盘行走并通过鼠标点击对话。第二阶段在玩家与辅导员对话后开启，参与坦克大战，代表电院使用IS-3坦克对战机动学院的虎式坦克，进行3V3的人机对战。通过头盔调整坦克的炮塔旋转与炮的上下移动瞄准，鼠标左键射击，键盘控制坦克移动。击毁对方全部坦克后游戏胜利。</p>
<p>以下为第一阶段的游戏截图。首先是同学做的交大电院大草坪附近的房屋模型，电子信息与电气工程学院楼，以及对面的机动学院楼，还有桥对面的行政楼。玩家可以在场景内自由移动。<br><img src="/images/VRTank/Game1.png" alt=""></p>
<p><img src="/images/VRTank/Game2.png" alt=""></p>
<p>然后是停在电院门口道路上的鼠式坦克，被设置为不可操纵，但是可以近距离进行观赏。模型是利用工具从坦克世界的客户端文件中提取模型与贴图，再通过maya进行贴图与调整，最终导入到游戏中来的。<br><img src="/images/VRTank/Game3.png" alt=""></p>
<p>接着可以看到停放在大草坪上的IS-3以及对方的虎式坦克。模型制作方法同上，但由于提取出的履带模型无法制作动画效果，这里双方的履带都是重新制作的。先制作单块的履带片，通过设置路径复制生成整条履带并拼合，随后与坦克进行连接。最终让所有履带片随路径进行移动，配合负重轮的旋转达成履带转动的效果动画。在驾驶坦克的过程中配合坦克的前进后退播放对应的动画即可。<br><img src="/images/VRTank/Game4.png" alt=""></p>
<p>在草坪边上还能看到一部分的围观学生，可以点击进行对话。而与辅导员对话可以开启坦克大战，进入第二阶段。素材来源为网上的某个素材网（忘了是从哪找的了），仅仅作为学习素材使用。<br><img src="/images/VRTank/Game5.png" alt=""></p>
<p>以下为第二阶段的截图。玩家将扮演IS-3坦克的驾驶员+观察手+炮手+车长。键盘wasd驾驶坦克进行移动，履行驾驶员的职责。佩戴Oculus设备的玩家的头部转动将旋转炮塔与移动炮管上下移动，履行观察手的职责。点击鼠标左键进行炮击，履行炮手的职责。炮弹将沿炮管方向进行飞行，同时检测碰撞的物体，如击中坦克则进行扣血操作，需要一定时间装填才能再度发射炮弹。击中坦克的车体与炮塔将产生不同的伤害值，当血量归0时坦克会爆炸，爆炸的推力将炮塔推至空中随后落下，此后坦克不会再动弹。击溃敌方所有坦克则为胜利，而被对方击毁则算失败。<br><img src="/images/VRTank/Game6.png" alt=""></p>
<p><img src="/images/VRTank/Game7.png" alt=""></p>
<p><img src="/images/VRTank/Game8.png" alt=""></p>
<p>杂谈：<br>此游戏为工科创的大作业，基于Oculus开发能够充分利用设备的性能的软件，由于本人的兴趣最终选择了制作坦克大战游戏。VR头盔带给人的沉浸式的体验，主要在于临场感，最适合制作的便是第一人称的游戏。游戏中不管是在校园中行走，与同学交谈，在观察口查看并驾驶坦克，都给人以真实的感觉。尤其是被对方炮弹击中时候的烟尘效果以及屏幕的剧烈震动，令玩家置身于虚拟而真实的战争之中。但是由于设备的分辨率，不能带眼睛游玩等限制，无法感受到更好的临场效果。并且通过键盘，鼠标来操作又是一种抽象的操纵方式。今后希望能够加入其它外设来解决玩家的输入问题。</p>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  
  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2017/07/17/项目/东方灵书阁/" itemprop="url">
                  东方灵书阁
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            <span class="post-meta-item-icon">
              <i class="fa fa-calendar-o"></i>
            </span>
            <span class="post-meta-item-text">发表于</span>
            <time itemprop="dateCreated" datetime="2017-07-17T23:04:39+08:00" content="2017-07-17">
              2017-07-17
            </time>
          </span>

          
            <span class="post-category" >
              &nbsp; | &nbsp;
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
              
                <span itemprop="about" itemscope itemtype="https://schema.org/Thing">
                  <a href="/categories/项目经历/" itemprop="url" rel="index">
                    <span itemprop="name">项目经历</span>
                  </a>
                </span>

                
                

              
            </span>
          

          
            
              <span class="post-comments-count">
                &nbsp; | &nbsp;
                <a href="/2017/07/17/项目/东方灵书阁/#comments" itemprop="discussionUrl">
                  <span class="post-comments-count ds-thread-count" data-thread-key="2017/07/17/项目/东方灵书阁/" itemprop="commentsCount"></span>
                </a>
              </span>
            
          

          

          
          

          
        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>游戏的制作时间为2013年3月至4月，算是本科期间第一款制作比较完整的游戏，为东方系列的同人游戏。项目有美术，音乐，程序，策划各一人，本人主要负责功能实现，素材整合与代码编写。游戏使用C++的SDL多媒体库，为Windows平台单机游戏。</p>
<p>操纵方式为一般的竖版弹幕射击游戏。上下左右（wasd）操纵人物移动，shift键减半移动速度并显示碰撞判定点。其他按键功能如图所示。<br><img src="/images/touhou/Instruction.png" alt=""></p>
<p>游戏指南后进入游戏主界面，可选择正常开始游戏Game Start（三条命），练习模式Practice（无限命），分数排行Score，音乐欣赏Music Room，选项Option（调整音效与背景音乐的音量），退出Quit。<br><img src="/images/touhou/MainMenu.png" alt=""></p>
<p>在音乐欣赏界面，可以选择播放本作中的共计7首曲子，2首原创曲以及5首变奏曲。还可以观看作曲者对于音乐的描述与对玩家的寄语。<br><img src="/images/touhou/MusicRoom.png" alt=""></p>
<p>而选择了开始游戏或练习模式后，将可以选择难度。共设置了简单普通困难三个难度。而难度的控制是通过随机弹幕的弹幕数量，子弹的发射速度来控制的。<br><img src="/images/touhou/DifficultySelection.png" alt=""></p>
<p>选择难度后进入战斗界面，会首先通过对话方式介绍剧情。对话由左侧我方人物立绘，右侧敌方人物立绘，半透明的对话框以及对话文字组成，类似于传统的Galgame游戏，目前并没有人物配音。战斗界面中骑着扫帚的魔理沙为本作的主角，玩家将控制她的移动与输出，规避敌方火力并对敌方进行火力投射。被子弹击中直接扣除一条命，进入短时间的无敌状态并重生在画面下方。右侧显示玩家得分，通过击落敌方，收集分数块增加。血槽，代表玩家的命，普通模式仅有三条命，被击中将减少三分之一的量。能量槽，通过收集能量块增加，每收集一定量之后能够加强己方火力，达到最大火力后将不会再掉落能量块，转为掉落能增加分数的分数结晶。<br><img src="/images/touhou/Game1.png" alt=""></p>
<p>接下来是一部分简单模式的游戏截图。<br><img src="/images/touhou/Game2.png" alt=""></p>
<p><img src="/images/touhou/Game3.png" alt=""></p>
<p><img src="/images/touhou/Game4.png" alt=""></p>
<p><img src="/images/touhou/Game5.png" alt=""></p>
<p><img src="/images/touhou/Game6.png" alt=""></p>
<p><img src="/images/touhou/Game7.png" alt=""></p>
<p><img src="/images/touhou/Game8.png" alt=""></p>
<p><img src="/images/touhou/Game9.png" alt=""></p>
<p><img src="/images/touhou/Game10.png" alt=""></p>
<p><img src="/images/touhou/Game11.png" alt=""></p>
<p><img src="/images/touhou/Game12.png" alt=""></p>
<p><img src="/images/touhou/Game13.png" alt=""></p>
<p><img src="/images/touhou/Game14.png" alt=""></p>
<p><img src="/images/touhou/Game15.png" alt=""></p>
<p>接下来是一部分困难模式的游戏截图。<br><img src="/images/touhou/Game16.png" alt=""></p>
<p><img src="/images/touhou/Game17.png" alt=""></p>
<p><img src="/images/touhou/Game18.png" alt=""><br>（我承认困难模式的最终BOSS过于暴走了基本很难无伤通过=-=）</p>
<p>共计三个关卡，通过之后播放结尾CG画面，制作人员表，最终游戏结束返回主菜单界面。</p>
<p>杂谈：<br>这款游戏应该是我第一款小组协力制作的游戏。项目负责人，也就是我们的主策划提供想法，拉来了美术与音乐大佬（都是以前同学），加上我一个程序完成了这款游戏。没有使用其他游戏引擎是因为希望尝试从零开始制作一款游戏。初中时候用过RPGMAKER，感觉就是在已经搭好的框架里加东西，限制挺大的。这里主要难点在于弹幕的设计与实现。策划给了我各阶段弹幕的设计图，而我需要使用代码去达成给定效果，同时还要通过变量区分三种难度，并进行不断的测试。这里大量使用了随机数产生速度与方向，正弦余弦函数产生圆形效果，玩家位置跟踪进行锁定射击等方法。最终版本在难度控制上还有些瑕疵，而且还有新的系统可以添加，倘若以后有时间再制作重置版吧（</p>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  
  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2017/05/25/HoloLens/HoloLens+Unity 空间映射/" itemprop="url">
                  HoloLens+Unity 空间映射
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            <span class="post-meta-item-icon">
              <i class="fa fa-calendar-o"></i>
            </span>
            <span class="post-meta-item-text">发表于</span>
            <time itemprop="dateCreated" datetime="2017-05-25T16:11:09+08:00" content="2017-05-25">
              2017-05-25
            </time>
          </span>

          
            <span class="post-category" >
              &nbsp; | &nbsp;
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
              
                <span itemprop="about" itemscope itemtype="https://schema.org/Thing">
                  <a href="/categories/HoloLens/" itemprop="url" rel="index">
                    <span itemprop="name">HoloLens</span>
                  </a>
                </span>

                
                

              
            </span>
          

          
            
              <span class="post-comments-count">
                &nbsp; | &nbsp;
                <a href="/2017/05/25/HoloLens/HoloLens+Unity 空间映射/#comments" itemprop="discussionUrl">
                  <span class="post-comments-count ds-thread-count" data-thread-key="2017/05/25/HoloLens/HoloLens+Unity 空间映射/" itemprop="commentsCount"></span>
                </a>
              </span>
            
          

          

          
          

          
        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>Namespace: UnityEngine.VR.WSA.SurfaceObserver</p>
<p>本主题介绍如何在Unity项目中使用空间映射（Spatial mapping），检索HoloLens世界中的各个表面的三角形网格，用于放置，遮挡，房间分析等。</p>
<p></p><h1>设置SpatialPerception功能</h1><br>为了使应用程序能够使用空间映射数据，必须启用SpatialPerception功能。<br>Edit &gt; Project Settings &gt; Player<br>点击Windows Store标签<br>打开Publishing Settings，在Capabilities list里勾起SpatialPerception<p></p>
<p>注意：如果已经将Unity项目导出到Visual Studio解决方案，则需要重新导出，或者在Visual Studio中的AppxManifest中手动设置此功能。</p>
<p>空间映射还需要MaxVersionTested至少为10.0.10586.0。<br>在Visual Studio中，在Solution Explorer中右键Package.appxmanifest并选择View Code<br>找到TargetDeviceFamily行，将MaxVersionTested改为10.0.10586.0。</p>
<p></p><h1>开始使用Unity内置空间映射组件</h1><br>Unity提供了两种易于处理空间映射的组件，Spatial Mapping Renderer和Spatial Mapping Collider。<p></p>
<p></p><h3>Spatial Mapping Renderer</h3><br>Spatial Mapping Renderer允许空间映射网格（Spatial Mapping Renderer）的可视化（Visualization）<p></p>
<p></p><h3>Spatial Mapping Collider</h3><br>Spatial Mapping Collider通过空间映射网格，可使全息内容或角色产生交互，如物理上的接触等。<p></p>
<p></p><h3>使用内置空间映射组件</h3><br>如果您想要同时进行物理表面的可视化和交互，您可以将两个组件添加到应用程序中。<br>1.在画面中选择一个需要检测空间表面网格（spatial surface meshes）的GameObject。<br>2.Add Component &gt; AR &gt; Spatial Mapping Collider or Spatial Mapping Renderer.<p></p>
<p></p><h3>更加深入</h3><br>可以通过低等级空间映射脚本API来实现网格处理。<br>可以使用HoloToolkit中的SpatialUnderstanding库来实现高等级网格分析。<p></p>
<p></p><h1>使用低等级Unity空间映射API</h1><br>如果您需要比从Spatial Mapping Renderer和Spatial Mapping Collider组件里得到更多的控件，则可以使用低级空间映射脚本API。<br>Namespace: Unity.Engine.VR.WSA<br>Types: SurfaceObserver, SurfaceChange, SurfaceData, SurfaceId<p></p>
<p></p><h3>开启SurfaceObserver</h3><br>SurfaceObserver surfaceObserver;<br> void Start () {<br>     surfaceObserver = new SurfaceObserver();<br> }<br> 指定的每个SurfaceObserver对象将通过调用SetVolumeAsSphere，SetVolumeAsAxisAlignedBox，SetVolumeAsOrientedBox或SetVolumeAsFrustum来提供数据的空间区域。您可以通过简单地再次调用其中一种方法来重新定义未来的空间区域。<br> void Start () {<br>    …<br>     surfaceObserver.SetVolumeAsAxisAlignedBox(Vector3.zero, new Vector3(3, 3, 3));<br>}<br>当调用SurfaceObserver.Update（）时，必须为具有新信息的SurfaceObserver的空间区域中的每个空间表面提供处理程序。<br>private void OnSurfaceChanged(SurfaceId surfaceId, SurfaceChange changeType, Bounds bounds, System.DateTime updateTime)<br> {<br>    //see Handling Surface Changes<br> }<br> <h3>处理Surface Changes</h3><br>System.Collections.Generic.Dictionary&lt;SurfaceId, GameObject&gt; spatialMeshObjects = new System.Collections.Generic.Dictionary&lt;SurfaceId, GameObject&gt;();<p></p>
<p>   private void OnSurfaceChanged(SurfaceId surfaceId, SurfaceChange changeType, Bounds bounds, System.DateTime updateTime)<br>   {<br>       switch (changeType)<br>       {<br>           case SurfaceChange.Added:<br>           case SurfaceChange.Updated:<br>               if (!spatialMeshObjects.ContainsKey(surfaceId))<br>               {<br>                   spatialMeshObjects[surfaceId] = new GameObject(“spatial-mapping-“ + surfaceId);<br>                   spatialMeshObjects[surfaceId].transform.parent = this.transform;<br>                   spatialMeshObjects[surfaceId].AddComponent<meshrenderer>();<br>               }<br>               GameObject target = spatialMeshObjects[surfaceId];<br>               SurfaceData sd = new SurfaceData(<br>                   //the surface id returned from the system<br>                   surfaceId,<br>                   //the mesh filter that is populated with the spatial mapping data for this mesh<br>                   target.GetComponent<meshfilter>() ?? target.AddComponent<meshfilter>(),<br>                   //the world anchor used to position the spatial mapping mesh in the world<br>                   target.GetComponent<worldanchor>() ?? target.AddComponent<worldanchor>(),<br>                   //the mesh collider that is populated with collider data for this mesh, if true is passed to bakeMeshes below<br>                   target.GetComponent<meshcollider>() ?? target.AddComponent<meshcollider>(),<br>                   //triangles per cubic meter requested for this mesh<br>                   1000,<br>                   //bakeMeshes - if true, the mesh collider is populated, if false, the mesh collider is empty.<br>                   true<br>                   );<br>               SurfaceObserver.RequestMeshAsync(sd, OnDataReady);<br>               break;<br>           case SurfaceChange.Removed:<br>               var obj = spatialMeshObjects[surfaceId];<br>               spatialMeshObjects.Remove(surfaceId);<br>               if (obj != null)<br>               {<br>                   GameObject.Destroy(obj);<br>               }<br>               break;<br>           default:<br>               break;<br>       }<br>   }<br>示例的Added &amp; Updated中，我们从字典中添加或获取表示此网格的GameObject，使用必要的组件创建一个SurfaceData结构，然后调用RequestMeshDataAsync以使用网格数据和场景中的位置填充GameObject。<br>在删除的情况下，我们从字典中删除表示此网格的GameObject并将其销毁。</meshcollider></meshcollider></worldanchor></worldanchor></meshfilter></meshfilter></meshrenderer></p>
<p></p><h3>处理Data Ready</h3><br>OnDataReady处理程序接收一个SurfaceData对象。 WorldAnchor，MeshFilter和MeshCollider（可选）对象包含反映相关空间表面的最新状态。通过访问MeshFilter对象的Mesh成员，可以执行网格数据的分析或处理。使用最新的网格渲染空间表面，或将其用于物理碰撞和射线。重要的是确认SurfaceData的内容不为空。<p></p>
<p></p><h3>在update中开始处理</h3><br>void Start () {<br>    …<br>     StartCoroutine(UpdateLoop());<br>}<br>IEnumerator UpdateLoop()<br>  {<br>      var wait = new WaitForSeconds(2.5f);<br>      while(true)<br>      {<br>          surfaceObserver.Update(OnSurfaceChanged);<br>          yield return wait;<br>      }<br>  }<p></p>
<p></p><h1>高等级网格分析：SpatialUnderstanding</h1><br>在HoloToolkit中有许多基于全息Unity API开发的实用程序代码。<p></p>
<p></p><h3>Spatial Understanding</h3><br>当在物理世界中放置全息图时，通常需要超越空间映射的网格和表面。当在程序上进行安置时，需要更高水平的环境理解。这通常需要做出关于什么是地板，天花板和墙壁的决定。此外，还能够针对一组放置约束进行优化，以确定全息对象最理想的物理位置。<br>HoloToolkit.SpatialUnderstanding库封装了空间理解技术，允许快速找到墙壁上的空白空间，将天花板上放置对象，识别出放置在角色上的位置，以及无数的其他空间理解查询。<br>所有的源代码都包含在HoloToolkit中，可以根据自己的需要进行自定义，并与社区分享您的改进。 C ++解算器的代码已被包装到UWP DLL中，并暴露给Unity，并且包含在HoloToolkit中的prefab中。<p></p>
<p></p><h3>理解模块</h3><br>模块暴露了三个主要接口：1.用于简单表面和空间查询的拓扑（topology）；2.对象检测的形状；3.用于基于约束的对象集放置的对象放置求解器（object placement solver）。这些中的每一个都会在接下来说明。除了三个主要模块接口之外，还可以使用射线投射（Ray casting）界面来检索标记的表面类型，并且可以复制自定义的水密（watertight）播放空间网格，<p></p>
<p></p><h3>射线投射（Ray casting）</h3><br>房间扫描完成后，内部会产生标签，如地板，天花板和墙壁等。 PlayspaceRaycast功能接收光线，如果光线与已知表面相撞则返回RaycastResult形式的显示关于该表面的信息。<br>struct RaycastResult<br>{<br>    enum SurfaceTypes<br>    {<br>        Invalid,    // No intersection<br>        Other,<br>        Floor,<br>        FloorLike,  // Not part of the floor topology,<br>                    //  but close to the floor and looks like the floor<br>        Platform,   // Horizontal platform between the ground and<br>                    //  the ceiling<br>        Ceiling,<br>        WallExternal,<br>        WallLike,   // Not part of the external wall surface,<br>                    //  but vertical surface that looks like a<br>                    //  wall structure<br>    };<br>    SurfaceTypes SurfaceType;<br>    float SurfaceArea;  // Zero if unknown<br>                        //  (i.e. if not part of the topology analysis)<br>    DirectX::XMFLOAT3 IntersectPoint;<br>    DirectX::XMFLOAT3 IntersectNormal;<br>};<br>在内部，raycast是根据播放空间中算好的8cm立方体素（voxel）计算出的。每个体素包含一组具有处理拓扑数据的表面元素（又称Surfels，surface element的缩写）。相交的体素单元中的surfels会被做对比，并用于查找拓扑信息的最佳匹配。该拓扑数据包含以“SurfaceTypes”枚举形式返回的标签以及相交表面的表面积。<br>在Unity示例中，光标（cursor）每帧投射一个光线。首先，Unity的collider。第二，理解模块的世界代表（world representation）。最后再次是UI元素。在这个应用程序中，UI获得最高优先级，接下来是理解结果，最后是Unity的collider。 SurfaceType在光标旁边报告为文本。<p></p>
<p></p><h3>拓扑查询（Topology Queries）</h3><br>在DLL中，拓扑管理器（manager）用于处理环境的标签。如上所述，大部分数据存储在体素体内包含的surfels中。此外，PlaySpaceInfos结构用于存储有关播放空间的信息，包括世界对齐（world alignment），楼层和天花板高度。启发式算法用于确定地板，天花板和墙壁。例如，表面积大于1平方米的最大和最低的水平面被认为是地板。请注意，扫描过程中的相机路径也是这么做的。<br>查询的一部分子集通过拓扑管理器暴露了出来。<br>QueryTopology_FindPositionsOnWalls<br>QueryTopology_FindLargePositionsOnWalls<br>QueryTopology_FindLargestWall<br>QueryTopology_FindPositionsOnFloor<br>QueryTopology_FindLargestPositionsOnFloor<br>QueryTopology_FindPositionsSittable<br>每个查询都有一组特定查询类型的参数。在以下示例中，用户指定所需体积的最小高度和宽度，高于地板的最小位置高度以及空间前的最小间隙量（clearnace）。所有测量均以米为单位。<br>EXTERN_C __declspec(dllexport) int QueryTopology_FindPositionsOnWalls(<br>    <em>In</em> float minHeightOfWallSpace,<br>    <em>In</em> float minWidthOfWallSpace,<br>    <em>In</em> float minHeightAboveFloor,<br>    <em>In</em> float minFacingClearance,<br>    <em>In</em> int locationCount,<br>    <em>Inout</em> Dll_Interface::TopologyResult* locationData)<br>这些查询中的每一个都使用预先分配的TopologyResult结构数组。locationCount参数指定数组中传递的长度。返回值报告返回位置的数量。此数字永远不会大于locationCount参数中传递的数字。<br>“拓扑结构”包含返回的体积的中心位置，面向的方向（normal）和找到的空间的尺寸。<br>struct TopologyResult<br>{<br>    DirectX::XMFLOAT3 position;<br>    DirectX::XMFLOAT3 normal;<br>    float width;<br>    float length;<br>};<br>请注意，在Unity示例中，每个查询都链接到虚拟UI面板中的按钮。样本为每个查询的参数设置合理的值。有关更多示例，请参阅示例代码中的SpaceVisualizer.cs。<p></p>
<p></p><h3>形状查询（Shape Queries）</h3><br>在dll的内部，形状分析器（ShapeAnalyzer_W）使用拓扑分析器来匹配用户定义的形状。 Unity样本定义一组形状，并通过应用内查询菜单在形状选项卡中公开结果。目的是用户可以根据自己的应用需要定义自己的对象形状查询并利用它们<br>注意，形状分析仅在水平表面上工作。例如，沙发由底座表面和沙发背部的平顶组成。形状查询查找特定尺寸，高度和宽高比范围的两个表面，两个表面对齐并连接。使用API​​术语的话，沙发座和后顶是形状组件，对齐要求是形状组件约束。<br>Unity样本（ShapeDefinition.cs）中为“sittable”对象定义的示例查询如下。<br>shapeComponents = new List<shapecomponent>()<br>{<br>    new ShapeComponent(<br>        new List<shapecomponentconstraint>()<br>        {<br>            ShapeComponentConstraint.Create_SurfaceHeight_Between(0.2f, 0.6f),<br>            ShapeComponentConstraint.Create_SurfaceCount_Min(1),<br>            ShapeComponentConstraint.Create_SurfaceArea_Min(0.035f),<br>        }<br>    ),<br>};<br>AddShape(“Sittable”, shapeComponents);<br>每个形状查询由一组形状组件定义，每个组件具有一组组件约束和一组形状约束，形状约束列出了组件之间的依赖关系。该示例在单个组件定义中包含三个约束，并且组件之间没有形状约束（因为只有一个组件）。<br>相比之下，沙发形状具有两个形状分量和四个形状约束。请注意，组件由用户组件列表中的索引标识（本示例中为0和1）。<br>shapeConstraints = new List<shapeconstraint>()<br>{<br>    ShapeConstraint.Create_RectanglesSameLength(0, 1, 0.6f),<br>    ShapeConstraint.Create_RectanglesParallel(0, 1),<br>    ShapeConstraint.Create_RectanglesAligned(0, 1, 0.3f),<br>    ShapeConstraint.Create_AtBackOf(1, 0),<br>};<br>Unity模块中提供了Wrapper功能，可以轻松创建自定义形状定义。组件和形状约束的完整列表可以在SpatialUnderstandingDll.cs中的ShapeComponentConstraint和ShapeConstraint结构中找到。<p></p>
<p></p><h3>物体布局求解器(Object Placement Solver)</h3><br>物体布局求解器可以用于识别物理室内放置物体的理想位置。求解器将找到给定对象规则和约束物体的最佳拟合位置。此外，直到使用Solver_RemoveObject或Solver_RemoveAllObjects调用删除对象，对象查询持续存在，并且允许受限的多对象放置。对象放置查询由三部分组成：具有参数的布局（placement）类型，规则列表和约束列表。要运行查询，请使用以下API。<br>public static int Solver_PlaceObject(<br>            [In] string objectName,<br>            [In] IntPtr placementDefinition,        // ObjectPlacementDefinition<br>            [In] int placementRuleCount,<br>            [In] IntPtr placementRules,             // ObjectPlacementRule<br>            [In] int constraintCount,<br>            [In] IntPtr placementConstraints,       // ObjectPlacementConstraint<br>            [Out] IntPtr placementResult)<br>此函数使用对象名称，布局定义以及规则和约束列表。 C＃包装器提供构造辅助函数（helper function），使规则和约束构造变得容易。布局定义包含的查询类型如下。<br>public enum PlacementType<br>            {<br>                Place_OnFloor,<br>                Place_OnWall,<br>                Place_OnCeiling,<br>                Place_OnShape,<br>                Place_OnEdge,<br>                Place_OnFloorAndCeiling,<br>                Place_RandomInAir,<br>                Place_InMidAir,<br>                Place_UnderFurnitureEdge,<br>            };<br>每个布局类型都有一组对该类型唯一的参数。ObjectPlacementDefinition结构包含一组用于创建这些定义的静态辅助函数。例如，要找到放置对象的地方，可以使用以下功能。 public static ObjectPlacementDefinition Create_OnFloor（Vector3 halfDims）除了布局类型之外，还可以提供一组规则和约束。规则不能违反。然后根据该组约束优化满足类型和规则的可能的放置位置，以便选择最佳的放置位置。每个规则和约束都可以通过提供的静态创建功能创建。下面提供了一个示例规则和约束构造函数。<br>public static ObjectPlacementRule Create_AwayFromPosition(<br>    Vector3 position, float minDistance)<br>public static ObjectPlacementConstraint Create_NearPoint(<br>    Vector3 position, float minDistance = 0.0f, float maxDistance = 0.0f)<br>以下对象放置查询正在寻找一个放置在表面边缘的半米立方体的位置，远离其他先前放置的对象并靠近房间中心的位置。<br>List<objectplacementrule> rules =<br>    new List<objectplacementrule>() {<br>        ObjectPlacementRule.Create_AwayFromOtherObjects(1.0f),<br>    };<p></p>
<p>List<objectplacementconstraint> constraints =<br>    new List<objectplacementconstraint> {<br>        ObjectPlacementConstraint.Create_NearCenter(),<br>    };</objectplacementconstraint></objectplacementconstraint></p>
<p>Solver_PlaceObject(<br>    “MyCustomObject”,<br>    new ObjectPlacementDefinition.Create_OnEdge(<br>        new Vector3(0.25f, 0.25f, 0.25f),<br>        new Vector3(0.25f, 0.25f, 0.25f)),<br>    rules.Count,<br>    UnderstandingDLL.PinObject(rules.ToArray()),<br>    constraints.Count,<br>    UnderstandingDLL.PinObject(constraints.ToArray()),<br>    UnderstandingDLL.GetStaticObjectPlacementResultPtr());<br>如果成功，则返回包含放置位置，尺寸和方向的ObjectPlacementResult结构。此外，该位置会添加到dll的放置对象的内部列表中。随后的展示位置查询将考虑此对象。Unity样本中的LevelSolver.cs文件包含更多示例查询。<br>在解决应用场景所需的多个对象的放置位置时，首先要解决不可或缺的大对象，以便最大限度地发现可以找到空间的概率。安置顺序很重要。如果无法找到对象展示位置，请尝试较少约束的配置。拥有一套后备配置能够支持更多的房间配置，这至关重要。</p>
<p></p><h3>房间扫描过程</h3><br>HoloLens提供的空间映射解决方案被设计为足够通用，可以满足整个问题空间的需求。空间理解模块是为了支持两个特定播放需求而构建的。其解决方案围绕具体过程和一系列假设进行构建，总结如下。<br>Fixed size playspace – The user specifies the maximum playspace size in the init call.<br>固定大小播放空间 - 用户指定init调用中的最大播放空间大小。<br>One-time scan process – The process requires a discrete scanning phase where the user walks around, defining the playspace. Query functions will not function until after the scan has been finalized.<br>一次性扫描过程 - 该过程需要一个离散的扫描阶段，用户可以在其中走动，定义播放空间。扫描完成后，查询功能才会起作用。<p></p>
<p>用户驱动的播放空间painting - 在扫描阶段，用户移动并观察播放速度，有效绘制应包含的区域。生成的网格对于在此阶段提供用户反馈很重要。室内的家庭或办公室设置 - 查询函数围绕平面和墙壁设计成直角。这是一个软限制。然而，在扫描阶段，完成主轴分析以优化沿主轴和短轴的网格细分。包含的SpatialUnderstanding.cs文件管理扫描阶段过程。它调用以下函数。<br>SpatialUnderstanding_Init – Called once at the start.<br>在开始时调用<br>GeneratePlayspace_InitScan – Indicates that the scan phase should begin.<br>表示扫描阶段应该开始。<br>GeneratePlayspace_UpdateScan_DynamicScan – Called each frame to update the scanning process. The camera position and orientation is passed in and is used for the playspace painting process, described above.<br>调用每个帧来更新扫描过程。相机的位置和方向被传入并用于上述的播放空间的绘画过程。<br>GeneratePlayspace_RequestFinish – Called to finalize the playspace. This will use the areas “painted” during the scan phase to define and lock the playspace. The application can query statistics during the scanning phase as well as query the custom mesh for providing user feedback.<br>被要求完成播放空间。这将在扫描阶段使用painting区域来定义和锁定播放空间。应用程序可以在扫描阶段查询统计信息，并查询自定义网格以提供用户反馈。<br>Import_UnderstandingMesh – During scanning, the “SpatialUnderstandingCustomMesh” behavior provided by the module and placed on the understanding prefab will periodically query the custom mesh generated by the process. In addition, this is done once more after scanning has been finalized.<br>在扫描期间，模块提供的放置在理解prefab的SpatialUnderstandingCustomMesh行为将定期查询由进程生成的自定义网格。此外，扫描完成后再进行一次。</p>
<p>扫描流由SpatialUnderstanding行为驱动，每个帧都调用InitScan，然后UpdateScan。当统计信息查询报告合理覆盖时，允许用户进行airtap，以调用RequestFinish来指示扫描阶段的结束。UpdateScan继续被调用，直到它的返回值表示dll已经完成处理。</p>
<p></p><h3>理解网格（Understanding Mesh）</h3><br>理解dll将播放空间内部存储为8厘米大小的体素立方体的网格。在扫描的初始部分，完成主要成分分析以确定房间的轴线。在内部，它存储与这些轴对齐的体素空间。通过从体素体积中提取等值面持续生成网格。<p></p>
<p>资料来源：<a href="https://developer.microsoft.com/en-us/windows/mixed-reality/spatial_mapping_in_unity" target="_blank" rel="external">https://developer.microsoft.com/en-us/windows/mixed-reality/spatial_mapping_in_unity</a></p>
</objectplacementrule></objectplacementrule></shapeconstraint></shapecomponentconstraint></shapecomponent>
          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  
  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2017/05/25/HoloLens/HoloLens+Unity 空间声/" itemprop="url">
                  HoloLens+Unity 空间声
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            <span class="post-meta-item-icon">
              <i class="fa fa-calendar-o"></i>
            </span>
            <span class="post-meta-item-text">发表于</span>
            <time itemprop="dateCreated" datetime="2017-05-25T15:16:13+08:00" content="2017-05-25">
              2017-05-25
            </time>
          </span>

          
            <span class="post-category" >
              &nbsp; | &nbsp;
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
              
                <span itemprop="about" itemscope itemtype="https://schema.org/Thing">
                  <a href="/categories/HoloLens/" itemprop="url" rel="index">
                    <span itemprop="name">HoloLens</span>
                  </a>
                </span>

                
                

              
            </span>
          

          
            
              <span class="post-comments-count">
                &nbsp; | &nbsp;
                <a href="/2017/05/25/HoloLens/HoloLens+Unity 空间声/#comments" itemprop="discussionUrl">
                  <span class="post-comments-count ds-thread-count" data-thread-key="2017/05/25/HoloLens/HoloLens+Unity 空间声/" itemprop="commentsCount"></span>
                </a>
              </span>
            
          

          

          
          

          
        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>本主题介绍如何在Unity项目中使用空间声（Spatial Sound）。它涵盖所需的插件文件以及启用立体声的Unity组件和属性。</p>
<p></p><h1>允许使用空间声</h1><br>使用声场定位插件启用Unity中的空间声。启用Microsoft HRTF扩展：<br>Edit &gt; Audio &gt; Spatializer<br>由于Microsoft Spatial Sound目前仅支持48000，您还应该将系统采样率设置为48000，以防止在系统输出设备未设置为48000的罕见情况下出现HRTF故障。<p></p>
<p>注意：虽然Windows 10 SDK可能用于Windows 10之前的Windows版本上构建的HoloLens应用程序，但如果不使用Windows 10，编辑器或设备上就不能获取空间声。</p>
<p></p><h1>在Unity中使用空间声</h1><br>通过调整音频源组件上的三个设置，就可在Unity项目中使用空间声。<br>在Hierarchy面板, 给game object添加Audio Source。<br>在Inspector面板, Audio Source组件下<br>勾起Spatialize选项。<br>设置Spatial Blend为3D（数值1）。<br>为了最好的效果, 扩展3D Sound Settings并且将Volume Rolloff设为Custom Rolloff。<p></p>
<p>这样声音就能真实存在于项目的环境中了！<br>强烈建议能够熟悉Spatial Sound设计指南。这些指南有助于将音频无缝集成到项目中，并进一步让用户感受这种体验。</p>
<p></p><h1>设置空间声</h1><br>Microsoft Spatial Sound插件允许调整每个音频源的上的参数，以允许对音频模拟的附加控制。<p></p>
<p></p><h3>最小增益（Minimum Gain）</h3><br>任意距离上的最小增益：-96 ~ +12分贝 默认为-96分贝。<p></p>
<p></p><h3>最大增益（Maximum Gain）</h3><br>任意距离上的最大增益：-96 ~ +12分贝 默认为+12分贝。<p></p>
<p></p><h3>统一增益距离（Unity Gain Distance）</h3><br>增益是0分贝的距离：0.05 ~ 无穷大米 默认为1米。<p></p>
<p></p><h3>房间尺寸</h3><br>空间声模拟的房间的尺寸。房间的尺寸有small（办公室到小会议室），medium（大型会议室）和large（礼堂）。还可以指定为none用于模拟户外环境。默认房间的尺寸是小型。<p></p>
<p></p><h3>例子</h3><br>HoloToolkit for Unity提供了一个静态类，可以使空间声设置变得容易。该类可以在HoloToolkit/SpatialSound文件夹中找到，可以从项目中的任何脚本调用。建议在项目中的每个音频源组件上设置这些参数。以下示例显示为附加音频源选择中等房间尺寸。<br>AudioSource audioSource = gameObject.GetComponent<audiosource>()<br>if (audioSource != null) {<br>    SpatialSoundSettings.SetRoomSize(audioSource, SpatialMappingRoomSizes.Medium);<br>}<p></p>
<p></p><h3>从Unity直接访问参数</h3><br>如果不想使用HoloToolkit中优秀的音频工具，可以通过更改HRTF参数来实现。可将以下代码放入SetHRTF.cs文件中并附加在每个HRTF AudioSource组件上，随后就能更改主要参数。<br>using UnityEngine;<br>using System.Collections;<br>public class SetHRTF : MonoBehaviour    {<br>   public enum ROOMSIZE { Small, Medium, Large, None };<br>   public ROOMSIZE room = ROOMSIZE.Small;  // Small is regarded as the “most average”<br>   // defaults and docs from MSDN<br>   // <a href="https://msdn.microsoft.com/en-us/library/windows/desktop/mt186602(v=vs.85).aspx" target="_blank" rel="external">https://msdn.microsoft.com/en-us/library/windows/desktop/mt186602(v=vs.85).aspx</a><br>   public float mingain = -96f; // The minimum gain limit applied at any distance, from -96 to + 12<br>   public float maxgain = 12f;  // The maximum gain applied at any distance, from -96 to + 12<br>   public float unityGainDistance = 1; // The distance at which the gain applied is 0dB, from 0.05 to infinity<br>   public float bypassCurves = 1; // if &gt; 0, will bypass Unity’s volume attenuation and make a more accurate volume simulation automatically in the plugin<br>   AudioSource audiosource;<br>   void Awake()<br>   {<br>       audiosource = this.gameObject.GetComponent<audiosource>();<br>       if (audiosource == null)<br>       {<br>           print(“SetHRTFParams needs an audio source to do anything.”);<br>           return;<br>       }<br>       audiosource.spatialize = 1; // we DO want spatialized audio<br>       audiosource.spread = 0; // we dont want to reduce our angle of hearing<br>       audiosource.spatialBlend = 1;   // we do want to hear spatialized audio<br>       audiosource.SetSpatializerFloat(1, (float)room);    // 1 is the roomsize param<br>       audiosource.SetSpatializerFloat(2, mingain); // 2 is the mingain param<br>       audiosource.SetSpatializerFloat(3, maxgain); // 3 is the maxgain param<br>       audiosource.SetSpatializerFloat(4, unityGainDistance); // 4 is the unitygain param<br>       audiosource.SetSpatializerFloat(5, bypassCurves );    // 5 is bypassCurves, which is usually a good idea<br>   }<br>}<p></p>
<p>资料来源：<a href="https://developer.microsoft.com/en-us/windows/mixed-reality/spatial_sound_in_unity" target="_blank" rel="external">https://developer.microsoft.com/en-us/windows/mixed-reality/spatial_sound_in_unity</a></p>
</audiosource></audiosource>
          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  
  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2017/05/25/HoloLens/HoloLens+Unity 坐标保持.md/" itemprop="url">
                  HoloLens+Unity 坐标保持
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            <span class="post-meta-item-icon">
              <i class="fa fa-calendar-o"></i>
            </span>
            <span class="post-meta-item-text">发表于</span>
            <time itemprop="dateCreated" datetime="2017-05-25T14:13:12+08:00" content="2017-05-25">
              2017-05-25
            </time>
          </span>

          
            <span class="post-category" >
              &nbsp; | &nbsp;
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
              
                <span itemprop="about" itemscope itemtype="https://schema.org/Thing">
                  <a href="/categories/HoloLens/" itemprop="url" rel="index">
                    <span itemprop="name">HoloLens</span>
                  </a>
                </span>

                
                

              
            </span>
          

          
            
              <span class="post-comments-count">
                &nbsp; | &nbsp;
                <a href="/2017/05/25/HoloLens/HoloLens+Unity 坐标保持.md/#comments" itemprop="discussionUrl">
                  <span class="post-comments-count ds-thread-count" data-thread-key="2017/05/25/HoloLens/HoloLens+Unity 坐标保持.md/" itemprop="commentsCount"></span>
                </a>
              </span>
            
          

          

          
          

          
        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>Namespace： UnityEngine.WSA.VR.Persistence<br>Class: WorldAnchorStore</p>
<p>WorldAnchorStore是创建全息体验的关键，其中全息图（holograms）保留在应用程序实例的特定现实世界中。这可以让您的用户将各个全息图或工作空间固定在任何需要的地方，然后根据用途在需要的时候找到它们。</p>
<p></p><h1>如何在会话间保持全息图</h1><br>WorldAnchorStore将允许您保持WorldAnchor跨会话（session）的位置。为了在会话中实际保留全息图，您需要单独跟踪使用特定世界锚点的GameObjects。创建具有世界锚点的GameObject根，再根据局部位置偏移确定子全息图。<p></p>
<p></p><h3>获得WorldAnchorStore</h3><br>WorldAnchorStore.GetAsync(StoreLoaded);<br>private void StoreLoaded(WorldAnchorStore store)<br>{<br>       this.store = store;<br>}<p></p>
<p></p><h3>保存WorldAnchor</h3><br>保存时，我们只需要命名我们正在保存的，并将其传递给以前保存的WorldAnchor。注意：尝试将两个锚保存到同一个字符串将失败（store.Save将返回false）。在保存新的之前，需要删除旧的保存。<br>private void SaveGame()<br>{<br>       // Save data about holograms positioned by this world anchor<br>       if (!this.savedRoot) // Only Save the root once<br>       {<br>              this.savedRoot = this.store.Save(“rootGameObject”, anchor);<br>              Assert(this.savedRoot);<br>       }<br>}<p></p>
<p></p><h3>读取WorldAnchor</h3><br>private void LoadGame()<br>{<br>       // Save data about holograms positioned by this world anchor<br>       this.savedRoot = this.store.Load(“rootGameObject”, rootGameObject);<br>       if (!this.savedRoot)<br>       {<br>              // We didn’t actually have the game root saved! We have to re-place our objects or start over<br>       }<br>}<br>还可以使用store.Delete（）来删除我们以前保存的锚，store.Clear（）来删除所有以前保存的数据。<p></p>
<p></p><h3>枚举存在的Anchors</h3><br>string[] ids = this.store.GetAllIds();<br>for (int index = 0; index &lt; ids.Length; index++)<br>{<br>        Debug.Log(ids[index]);<br>}<p></p>
<p>资料来源：<a href="https://developer.microsoft.com/en-us/windows/mixed-reality/persistence_in_unity" target="_blank" rel="external">https://developer.microsoft.com/en-us/windows/mixed-reality/persistence_in_unity</a></p>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  
  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2017/05/24/HoloLens/HoloLens+Unity 语音输入/" itemprop="url">
                  HoloLens+Unity 语音输入
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            <span class="post-meta-item-icon">
              <i class="fa fa-calendar-o"></i>
            </span>
            <span class="post-meta-item-text">发表于</span>
            <time itemprop="dateCreated" datetime="2017-05-24T23:07:30+08:00" content="2017-05-24">
              2017-05-24
            </time>
          </span>

          
            <span class="post-category" >
              &nbsp; | &nbsp;
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
              
                <span itemprop="about" itemscope itemtype="https://schema.org/Thing">
                  <a href="/categories/HoloLens/" itemprop="url" rel="index">
                    <span itemprop="name">HoloLens</span>
                  </a>
                </span>

                
                

              
            </span>
          

          
            
              <span class="post-comments-count">
                &nbsp; | &nbsp;
                <a href="/2017/05/24/HoloLens/HoloLens+Unity 语音输入/#comments" itemprop="discussionUrl">
                  <span class="post-comments-count ds-thread-count" data-thread-key="2017/05/24/HoloLens/HoloLens+Unity 语音输入/" itemprop="commentsCount"></span>
                </a>
              </span>
            
          

          

          
          

          
        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>Unity允许三种方式的语音输入。使用KeywordRecognizer（PhraseRecognizers的两类型之一）可以监听一系列命令。使用GrammarRecognizer（PhraseRecognizer的另一种类型）可以监听SRGS文件中定义的特定语法。使用DictationRecognizer可以监听任何单词并且能展示给用户。<br>注意：dictation和phrase recognition同一时刻只能处理一种。</p>
<p></p><h1>允许语音输入</h1><br>Edit &gt; Project Settings &gt; Player<br>Click on the “Windows Store” tab<br>In the “Publishing Settings &gt; Capabilities” section, check the Microphone capability<p></p>
<p></p><h1>Phrase Recognition</h1><p></p>
<p></p><h3>KeywordRecognizer</h3><br>Namespace: UnityEngine.Windows.Speech<br>Types: KeywordRecognizer, PhraseRecognizedEventArgs, SpeechError, SpeechSystemStatus<p></p>
<p>using UnityEngine.Windows.Speech;<br>using System.Collections.Generic;<br>using System.Linq;</p>
<p>KeywordRecognizer keywordRecognizer;<br>Dictionary&lt;string, System.Action&gt; keywords = new Dictionary&lt;string, System.Action&gt;();<br>在Start()中添加keywords<br>//Create keywords for keyword recognizer<br>keywords.Add(“activate”, () =&gt;<br>{<br>    // action to be performed when this keyword is spoken<br>});<br>keywordRecognizer = new KeywordRecognizer(keywords.Keys.ToArray());<br>keywordRecognizer.OnPhraseRecognized += KeywordRecognizer_OnPhraseRecognized;<br>private void KeywordRecognizer_OnPhraseRecognized(PhraseRecognizedEventArgs args)<br>{<br>    System.Action keywordAction;<br>    // if the keyword recognized is in our dictionary, call that Action.<br>    if (keywords.TryGetValue(args.text, out keywordAction))<br>    {<br>        keywordAction.Invoke();<br>    }<br>}<br>keywordRecognizer.Start();</p>
<p></p><h3>GrammarRecognizer</h3><br>Namespace: UnityEngine.Windows.Speech<br>Types: GrammarRecognizer, PhraseRecognizedEventAtgs, SpeechError, SpeechSystemStatus<br>GrammerRecognizer利用SRGS文件识别，适用于有复杂的phrase，大量keywords的情况。需要自己创建SRGS XML文件。<p></p>
<p><project_root>/Assets/StreamingAssets/SRGS/myGrammar.xml<br>private GrammarRecognizer grammarRecognizer;<br>grammarRecognizer = new GrammarRecognizer(Application.streamingDataPath + “/SRGS/myGrammar.xml”);<br>grammarRecognizer.OnPhraseRecognized += grammarRecognizer_OnPhraseRecognized;<br>private void Grammar_OnPhraseRecognized(PhraseRecognizedEventArgs args)<br>{<br>    SemanticMeaning[] meanings = args.semanticMeanings;<br>    // do something<br>}<br>grammarRecognizer.Start();</project_root></p>
<p></p><h1>Dictation</h1><br>Namespace: UnityEngine.Windows.Speech<br>Types:DictationRecognizer, SpeechError, SeechSystemStatus<br>DictationRecognizer可以将用户的语音转变为文本。DictationRecognizer公开了听写功能，并支持注册和监听短语完成的事件。Start（）和Stop（）方法分别启用和禁用听写识别。使用识别器完成后，应使用Dispose（）方法来释放其使用的资源。如果垃圾收集之前没有释放，它将以额外的性能成本自动释放这些资源。<p></p>
<p></p><h3>允许dictation</h3><br>Edit &gt; Project Settings &gt; Player<br>Click on the “Windows Store” tab<br>In the “Publishing Settings &gt; Capabilities” section, check the InternetClient capability<p></p>
<p></p><h3>DictationRecognizer</h3><br>dictationRecognizer = new DictationRecognizer();<br>dictationRecognizer有四种事件<p></p>
<p></p><h5>DictationResult</h5><br>事件在用户语音停止时触发，通常在句子结尾处触发此事件。完整识别的字符串在这里返回。<br>dictationRecognizer.DictationResult += DictationRecognizer_DictationResult;<br>private void DictationRecognizer_DictationResult(string text, ConfidenceLevel confidence)<br>{<br>    // do something<br>}<p></p>
<p></p><h5>DictationHypothesis</h5><br>这个事件在用户正在说话时被持续触发。当识别器侦听时，它提供了迄今为止所听到的内容。<br>dictationRecognizer.DictationHypothesis += DictationRecognizer_DictationHypothesis;<br>private void DictationRecognizer_DictationHypothesis(string text)<br>{<br>    // do something<br>}<p></p>
<p></p><h5>DictationComplete</h5><br>无论从Stop（）被调用，是否发生超时或其他错误，识别器都将停止此事件。<br>dictationRecognizer.DictationComplete += DictationRecognizer_DictationComplete;<br>private void DictationRecognizer_DictationComplete(DictationCompletionCause cause)<br>{<br>   // do something<br>}<p></p>
<p></p><h5>DictationError</h5><br>事件在发生错误时触发。<br>dictationRecognizer.DictationError += DictationRecognizer_DictationError;<br>private void DictationRecognizer_DictationError(string error, int hresult)<br>{<br>    // do something<br>}<p></p>
<p>开启<br>dictationRecognizer.Start();<br>关闭<br>dictationRecognizer.DictationResult -= DictationRecognizer_DictationResult;<br>dictationRecognizer.DictationComplete -= DictationRecognizer_DictationComplete ;<br>dictationRecognizer.DictationHypothesis -= DictationRecognizer_DictationHypothesis ;<br>dictationRecognizer.DictationError -= DictationRecognizer_DictationError ;<br>dictationRecognizer.Dispose();</p>
<p>注意<br>Start（）和Stop（）方法分别启用和禁用听写识别。<br>使用识别器完成后，应使用Dispose（）方法来释放其使用的资源。<br>超时发生的一段时间后，可以在DictationComplete事件中检查这些超时。<br>需要注意的超时有两种：<br>如果识别器开始并且在前5秒钟内没有听到任何音频，它将超时。<br>如果识别器给出了一个结果，然后听到静音二十秒钟，它将超时。</p>
<p></p><h1>同时使用Phrase Recognition和Dictation</h1><br>同一时间只能使用一个。需要将另一个关闭才能开启这一个。<br>PhraseRecognitionSystem.Shutdown();<br>PhraseRecognitionSystem.Restart();<p></p>
<p>资料来源：<a href="https://developer.microsoft.com/en-us/windows/mixed-reality/voice_input_in_unity" target="_blank" rel="external">https://developer.microsoft.com/en-us/windows/mixed-reality/voice_input_in_unity</a></p>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  
  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2017/05/24/HoloLens/HoloLens+Unity 手势与运动控制/" itemprop="url">
                  HoloLens+Unity 手势与运动控制
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            <span class="post-meta-item-icon">
              <i class="fa fa-calendar-o"></i>
            </span>
            <span class="post-meta-item-text">发表于</span>
            <time itemprop="dateCreated" datetime="2017-05-24T22:03:15+08:00" content="2017-05-24">
              2017-05-24
            </time>
          </span>

          
            <span class="post-category" >
              &nbsp; | &nbsp;
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
              
                <span itemprop="about" itemscope itemtype="https://schema.org/Thing">
                  <a href="/categories/HoloLens/" itemprop="url" rel="index">
                    <span itemprop="name">HoloLens</span>
                  </a>
                </span>

                
                

              
            </span>
          

          
            
              <span class="post-comments-count">
                &nbsp; | &nbsp;
                <a href="/2017/05/24/HoloLens/HoloLens+Unity 手势与运动控制/#comments" itemprop="discussionUrl">
                  <span class="post-comments-count ds-thread-count" data-thread-key="2017/05/24/HoloLens/HoloLens+Unity 手势与运动控制/" itemprop="commentsCount"></span>
                </a>
              </span>
            
          

          

          
          

          
        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>对于gaze物体的行为有两种方式实现，手势（gestures）和运动控制器（motion controllers）。Unity可以提供如位置，方向，速度等的低等级信息，也可提供高等级的手势识别事件，如tap，hold等。</p>
<p></p><h1>手势：高等级空间输入</h1><br>Namespace: UnityEngine.VR.WSA.Input<br>Types: GestureRecognizer, GestureSettings, InteractionSourceKind<p></p>
<p>这些高等级手势都由空间输入信息生成的。每个手势事件都会提供一些具体信息。</p>
<p></p><h3>创建Gesture Recognizer</h3><br>GestureRecognizer recognizer = new GestureRecognizer();<p></p>
<p></p><h3>确定监听哪个gesture</h3><br>recognizer.SetRecognizableGestures(GestureSettings.Tap | GestureSettings.Hold);<p></p>
<p></p><h3>为gesture注册监听事件</h3><br>recognizer.TappedEvent += MyTapEventHandler;<br>recognizer.HoldEvent += MyHoldEventHandler;<br>注意：Navigation和Manipulation手势在GestureRecognizer实例中是互斥的。<p></p>
<p></p><h3>开始捕捉gesture</h3><br>recognizer.StartCapturingGestures();<br>在调用前GestureRecognizer不会监视输入。如果在处理StopCapturingGestures（）的框架之前执行了输入，则可能会在StopCapturingGestures（）被调用后生成手势事件。因此，如果要根据玩家目前注视的对象来启动和停止手势监控，这是可靠的。<p></p>
<p></p><h3>停止捕捉gesture</h3><br>recognizer.StopCapturingGestures();<p></p>
<p></p><h3>移除gesture recognizer</h3><br>void OnDestroy()<br>{<br>    recognizer.TappedEvent -= MyTapEventHandler;<br>    recognizer.HoldEvent -= MyHoldEventHandler;<br>}<p></p>
<p></p><h1>交互：低等级空间输入</h1><br>Namespace: UnityEngine.VR.WSA.Input<br>Types: InteractionManager, InteractionSourceState, InteractionSource, InteractionSourceProperties, InteractionSourceKind, InteractionSourceLocation<p></p>
<p></p><h3>开始处理interaction事件</h3><br>InteractionManager.SourcePressed += InteractionManager_SourcePressed;<p></p>
<p>void InteractionManager_SourcePressed(InteractionSourceState state)<br>{<br>    // state has information about:<br>       // targeting head ray at the time when the event was triggered<br>       // whether the source is pressed or not<br>       // properties like position, velocity, source loss risk<br>       // source id (which hand id for example) and source kind like hand, voice, controller or other<br>}</p>
<p></p><h3>停止处理事件</h3><br>InteractionManager.SourcePressed -= InteractionManager_SourcePressed;<p></p>
<p></p><h3>Input Source Change Events</h3><br>detected (becomes active)<br>lost (becomes inactive)<br>updates (moves or otherwise changes some state)<br>is pressed (tap, button press, or select uttered)<br>is released (end of a tap, button released, or end of select uttered)<p></p>
<p></p><h3>Input Source State</h3><br>每个事件都会输出InteractionSourceState，代表了某个时间点的数据。数据包括<br>发生了哪种press (Select/Menu/Grasp/Touchpad/Thumbstick)<br>运动控制器的详细信息, such as XY coordinates and touched state from touchpad/thumbstick<br>某时刻的位置，方向，速度。<br>头朝向的射线，用来确定时间发生时用户gaze的物体，因为用户可能在前一帧做过手势。<br>来源的射线，如果这是个有朝向的运动控制器。<br>InteractionSourceKind来判断这是个手还是运动控制器<p></p>
<p></p><h3>例子</h3><br>using UnityEngine.VR.WSA.Input;<p></p>
<p>void Start ()<br>{<br>    InteractionManager.SourceDetected += InteractionManager_SourceDetected;<br>    InteractionManager.SourceUpdated += InteractionManager_SourceUpdated;<br>    InteractionManager.SourceLost += InteractionManager_SourceLost;<br>    InteractionManager.SourcePressed += InteractionManager_SourcePressed;<br>    InteractionManager.SourceReleased += InteractionManager_SourceReleased;<br>}</p>
<p>void OnDestroy()<br>{<br>    InteractionManager.SourceDetected -= InteractionManager_SourceDetected;<br>    InteractionManager.SourceUpdated -= InteractionManager_SourceUpdated;<br>    InteractionManager.SourceLost -= InteractionManager_SourceLost;<br>    InteractionManager.SourcePressed -= InteractionManager_SourcePressed;<br>    InteractionManager.SourceReleased -= InteractionManager_SourceReleased;<br>}</p>
<p>void InteractionManager_SourceDetected(InteractionSourceState state)<br>{<br>    // Source was detected<br>    // state has the current state of the source including id, position, kind, etc.<br>}</p>
<p>void InteractionManager_SourceLost(InteractionSourceState state)<br>{<br>    // Source was lost. This will be after a SourceDetected event and no other events for this source id will occur until it is Detected again<br>    // state has the current state of the source including id, position, kind, etc.<br>}</p>
<p>void InteractionManager_SourceUpdated(InteractionSourceState state)<br>{<br>    // Source was updated. The source would have been detected before this point<br>    // state has the current state of the source including id, position, kind, etc.<br>}</p>
<p>void InteractionManager_SourcePressed(InteractionSourceState state)<br>{<br>    // Source was pressed. This will be after the source was detected and before it is released or lost<br>    // state has the current state of the source including id, position, kind, etc.<br>}</p>
<p>void InteractionManager_SourceReleased(InteractionSourceState state)<br>{<br>    // Source was released. The source would have been detected and pressed before this point. This event will not fire if the source is lost<br>    // state has the current state of the source including id, position, kind, etc.<br>}</p>
<p>资料来源：<a href="https://developer.microsoft.com/en-us/windows/mixed-reality/gestures_and_motion_controllers_in_unity" target="_blank" rel="external">https://developer.microsoft.com/en-us/windows/mixed-reality/gestures_and_motion_controllers_in_unity</a></p>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  
  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2017/05/23/HoloLens/HoloLens+Unity Gaze/" itemprop="url">
                  HoloLens+Unity Gaze
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            <span class="post-meta-item-icon">
              <i class="fa fa-calendar-o"></i>
            </span>
            <span class="post-meta-item-text">发表于</span>
            <time itemprop="dateCreated" datetime="2017-05-23T22:07:07+08:00" content="2017-05-23">
              2017-05-23
            </time>
          </span>

          
            <span class="post-category" >
              &nbsp; | &nbsp;
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
              
                <span itemprop="about" itemscope itemtype="https://schema.org/Thing">
                  <a href="/categories/HoloLens/" itemprop="url" rel="index">
                    <span itemprop="name">HoloLens</span>
                  </a>
                </span>

                
                

              
            </span>
          

          
            
              <span class="post-comments-count">
                &nbsp; | &nbsp;
                <a href="/2017/05/23/HoloLens/HoloLens+Unity Gaze/#comments" itemprop="discussionUrl">
                  <span class="post-comments-count ds-thread-count" data-thread-key="2017/05/23/HoloLens/HoloLens+Unity Gaze/" itemprop="commentsCount"></span>
                </a>
              </span>
            
          

          

          
          

          
        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>Gaze（凝视）是Hololens中用户用于确定全息目标的基本方法，用户视野中会出现一个随视角移动的光标用于选择物体。光标的产生是由用户的头向HoloLens发出射线，根据射线的碰撞位置显示。</p>
<p>在unity中，用户头的位置和方向和主相机一致，即UnityEngine.Camera.main.tranform.position与 UnityEngine.Camera.main.tranform.forward。随后即可通过物理射线Physics.RayCast导致的射线碰撞RaycastHit来确定碰撞到的物体是哪一个。<br>void Update()<br>{<br>       RaycastHit hitInfo;<br>       if (Physics.Raycast(<br>               Camera.main.transform.position,<br>               Camera.main.transform.forward,<br>               out hitInfo,<br>               20.0f,<br>               Physics.DefaultRaycastLayers))<br>       {<br>           // If the Raycast has succeeded and hit a hologram<br>           // hitInfo’s point represents the position being gazed at<br>           // hitInfo’s collider GameObject represents the hologram being gazed at<br>       }<br>}</p>
<p>关于gaze的可视化可以在GitHub的HoloToolkit-Unity仓库的GazeManager.cs中找到。Cursor.prefab和CursorWithFeedback.prefab展示了如何进行gaze光标的可视化。</p>
<p>资料来源：<a href="https://developer.microsoft.com/en-us/windows/mixed-reality/gaze_in_unity" target="_blank" rel="external">https://developer.microsoft.com/en-us/windows/mixed-reality/gaze_in_unity</a></p>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  
  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2017/05/23/HoloLens/HoloLens+Unity 坐标系统/" itemprop="url">
                  HoloLens+Unity 坐标系统
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            <span class="post-meta-item-icon">
              <i class="fa fa-calendar-o"></i>
            </span>
            <span class="post-meta-item-text">发表于</span>
            <time itemprop="dateCreated" datetime="2017-05-23T20:53:39+08:00" content="2017-05-23">
              2017-05-23
            </time>
          </span>

          
            <span class="post-category" >
              &nbsp; | &nbsp;
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
              
                <span itemprop="about" itemscope itemtype="https://schema.org/Thing">
                  <a href="/categories/HoloLens/" itemprop="url" rel="index">
                    <span itemprop="name">HoloLens</span>
                  </a>
                </span>

                
                

              
            </span>
          

          
            
              <span class="post-comments-count">
                &nbsp; | &nbsp;
                <a href="/2017/05/23/HoloLens/HoloLens+Unity 坐标系统/#comments" itemprop="discussionUrl">
                  <span class="post-comments-count ds-thread-count" data-thread-key="2017/05/23/HoloLens/HoloLens+Unity 坐标系统/" itemprop="commentsCount"></span>
                </a>
              </span>
            
          

          

          
          

          
        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>HoloLens支持不同的体验范围（experience scales）。有orientation-only, seated-scale, room-scale, world-scale等几种。</p>
<p></p><h1>Orientation-only or Seated-scale Experience</h1><br>Namespace: UnityEngine.VR<br>Type: InputTracking<br>可以直接在Unity的世界坐标系中进行编辑，出现在相机视野里的物体将出现在应用中。<p></p>
<p>纯粹的orientation-only experience:<br>InputTracking.disablePositionalTracking = true;</p>
<p>seated-scale experience中重新调整seat位置：<br>InputTracking.Recenter();</p>
<p></p><h1>Standing-scale or Room-scale Experience</h1><br>Namespace: UnityEngine.VR.WSA<br>Type: StageRoot<br>第一次开启时检测地板与房间边界（墙壁）的位置，定义的物体将在此范围内。<p></p>
<p>要将Unity层次结构的分支定位到用户定义的层起始点，需将StageRoot组件添加到根游戏对象，随后这个对象将保持在指定的位置。<br>在脚本中可以通过调用StageRoot中的TryGetBounds方法获得边界多边形，随后即可进行碰撞检测。注意系统将在用户碰到时自动显示边界。</p>
<p></p><h1>World-scale Experience</h1><br>Namespace: UnityEngine.VR.WSA<br>Type: WorldAnchor<p></p>
<p>world-scale experience允许用户移动超过5米，这需要些额外的新技术。一种是空间锚点（spatial anchor）。不管用户走到哪，锚点会保存一系列的物理世界中全息图（holograms）以便后面使用。<br>在unity中，添加WorldAnchor组件给GameObject即可创建空间锚点。</p>
<p></p><h3>添加WorldAnchor</h3><br>WorldAnchor anchor = gameObject.AddComponent<worldanchor>();<p></p>
<p></p><h3>移除添加WorldAnchor</h3><br>当前帧不移动<br>Destroy(gameObject.GetComponent<worldanchor>());<br>当前帧移动<br>DestroyImmediate(gameObject.GetComponent<worldanchor>());<p></p>
<p></p><h3>移动锚点物体</h3><br>DestroyImmediate(gameObject.GetComponent<worldanchor>());<br>gameObject.transform.position = new Vector3(0, 0, 2);<br>WorldAnchor anchor = gameObject.AddComponent<worldanchor>();<p></p>
<p></p><h3>处理可定位变化</h3><br>WorldAnchor在某个时间点可能无法在物理世界中找到。如果发生这种情况，Unity将不会更新锚点对象的变换。这也可以在应用程序运行时更改。不能处理可定位性的变化将导致物体不会出现在世界上正确的物理位置。需要注册OnTrackingChanged事件，随后处理事件。OnTrackingChanged事件将在空间锚点可定位与不可定位切换时触发。<br>anchor.OnTrackingChanged += Anchor_OnTrackingChanged;<br>private void Anchor_OnTrackingChanged(WorldAnchor self, bool located)<br>{<br>       // This simply activates/deactivates this object and all children when tracking changes<br>    self.gameObject.SetActiveRecursively(located);<br>}<br>调用<br>Anchor_OnTrackingChanged(anchor, anchor.isLocated);<p></p>
<p>资料来源：<a href="https://developer.microsoft.com/en-us/windows/mixed-reality/Coordinate_systems_in_Unity.html#building_a_standing-scale_or_room-scale_experience" target="_blank" rel="external">https://developer.microsoft.com/en-us/windows/mixed-reality/Coordinate_systems_in_Unity.html#building_a_standing-scale_or_room-scale_experience</a></p>
</worldanchor></worldanchor></worldanchor></worldanchor></worldanchor>
          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  
  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2017/05/23/HoloLens/HoloLens+Unity 开发环境搭建/" itemprop="url">
                  HoloLens+Unity 开发环境搭建
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            <span class="post-meta-item-icon">
              <i class="fa fa-calendar-o"></i>
            </span>
            <span class="post-meta-item-text">发表于</span>
            <time itemprop="dateCreated" datetime="2017-05-23T20:22:55+08:00" content="2017-05-23">
              2017-05-23
            </time>
          </span>

          
            <span class="post-category" >
              &nbsp; | &nbsp;
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
              
                <span itemprop="about" itemscope itemtype="https://schema.org/Thing">
                  <a href="/categories/HoloLens/" itemprop="url" rel="index">
                    <span itemprop="name">HoloLens</span>
                  </a>
                </span>

                
                

              
            </span>
          

          
            
              <span class="post-comments-count">
                &nbsp; | &nbsp;
                <a href="/2017/05/23/HoloLens/HoloLens+Unity 开发环境搭建/#comments" itemprop="discussionUrl">
                  <span class="post-comments-count ds-thread-count" data-thread-key="2017/05/23/HoloLens/HoloLens+Unity 开发环境搭建/" itemprop="commentsCount"></span>
                </a>
              </span>
            
          

          

          
          

          
        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>毕业设计选择了在HoloLens上进行应用开发，这里记录一下HoloLens的学习过程。目前打算制作基于HoloLens的三维中国象棋游戏，采用了Unity作为开发工具，毕竟微软提供了各种API接口供调用，应该算是最快速的开发方式之一了。</p>
<p></p><h1>开发环境搭建</h1><br>1.Visual Studio 2017 微软产品通用的开发工具。在Unity游戏完成后将其作为VS文件导出，再通过Visual Studio打开，编译并运行。<br>2.HoloLens Emulator HoloLens模拟器，其实就是虚拟机。需要Windows 10专业版或教育版才能运行，因为需要Hyper-V支持。Mac电脑可以装双系统的Windows使用模拟器，但是需要在Bootcamp中设置windows系统为首选系统开启才能使用，不然会检测到BIOS不支持虚拟机进而打不开模拟器。<br>3.Unity 5.5版本以上 游戏的主要开发环境，需要为HoloLens的使用进行配置。<br>Select File &gt; Build Settings…<br>Select Windows Store in the Platform list and click Switch Platform<br>Set SDK to Universal 10<br>Set Target device to Any Device to support immersive headsets or switch to HoloLens<br>Set Build Type to D3D<br>Set UWP SDK to Latest installed<p></p>
<p>From the Build Settings… window, open Player Settings…<br>Select the Settings for Windows Store tab<br>Expand the Other Settings group<br>In the Rendering section, check the Virtual Reality Supported checkbox to add a new Virtual Reality Devices list and confirm “Windows Mixed Reality” is listed as a supported device (this will appear as “Windows Holographic” on some versions of Unity)</p>
<p>一些功能需要额外开启<br>Player Settings &gt; Windows Store &gt; Publishing Settings &gt; Capabilities<br>SpatialPerception: SurfaceObserver<br>WebCam: PhotoCapture and VideoCapture<br>PicturesLibrary/VideosLibrary: PhotoCapture or VideoCapture, respectively (when storing the captured content)<br>Microphone: VideoCapture (when capturing audio), DictationRecognizer, GrammarRecognizer, and KeywordRecognizer<br>InternetClient: DictationRecognizer (and to use the Unity Profiler)</p>
<p>HoloLens的GPU仅是移动版的，需要降低图像质量来获得更高的速度<br>Select Edit &gt; Project Settings &gt; Quality<br>Select the dropdown under the Windows Store logo and select Fastest. You’ll know the setting is applied correctly when the box in the Windows Store column and Fastest row is green.</p>
<p>场景中的主相机需要进行设定<br>In the Inspector panel, set the transform position to 0, 0, 0 so the location of the users head starts at the Unity world origin.<br>Change Clear Flags to Solid Color.<br>Change the Background color to RGBA 0,0,0,0. Black renders as transparent in HoloLens.<br>Change Clipping Planes - Near to the HoloLens recommended 0.85 (meters).</p>
<p>一些额外的功能可以通过Unity APIs来实现，具体可以在Unity manual或Unity scripting reference中找到</p>
<p>资料来源：<a href="https://developer.microsoft.com/en-us/windows/mixed-reality/unity_development_overview" target="_blank" rel="external">https://developer.microsoft.com/en-us/windows/mixed-reality/unity_development_overview</a></p>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
  </section>

  
  <nav class="pagination">
    <span class="page-number current">1</span><a class="page-number" href="/page/2/">2</a><a class="extend next" rel="next" href="/page/2/"><i class="fa fa-angle-right"></i></a>
  </nav>



          </div>
          


          

        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    <div class="sidebar-inner">

      

      

      <section class="site-overview sidebar-panel  sidebar-panel-active ">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
          <img class="site-author-image" itemprop="image"
               src="/images/avatar.png"
               alt="Kangarootao" />
          <p class="site-author-name" itemprop="name">Kangarootao</p>
          <p class="site-description motion-element" itemprop="description"></p>
        </div>
        <nav class="site-state motion-element">
          <div class="site-state-item site-state-posts">
            <a href="/archives">
              <span class="site-state-item-count">20</span>
              <span class="site-state-item-name">日志</span>
            </a>
          </div>

          
            <div class="site-state-item site-state-categories">
              <a href="/categories">
                <span class="site-state-item-count">8</span>
                <span class="site-state-item-name">分类</span>
              </a>
            </div>
          

          
            <div class="site-state-item site-state-tags">
              <a href="/tags">
                <span class="site-state-item-count">7</span>
                <span class="site-state-item-name">标签</span>
              </a>
            </div>
          

        </nav>

        

        <div class="links-of-author motion-element">
          
            
              <span class="links-of-author-item">
                <a href="https://github.com/kangarootao" target="_blank" title="GitHub">
                  
                    <i class="fa fa-fw fa-github"></i>
                  
                  GitHub
                </a>
              </span>
            
              <span class="links-of-author-item">
                <a href="http://weibo.com/kangarootao" target="_blank" title="微博">
                  
                    <i class="fa fa-fw fa-globe"></i>
                  
                  微博
                </a>
              </span>
            
          
        </div>

        
        

        
        

      </section>

      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright" >
  
  &copy; 
  <span itemprop="copyrightYear">2017</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">Kangarootao</span>
</div>

<div class="powered-by">
  由 <a class="theme-link" href="http://hexo.io">Hexo</a> 强力驱动
</div>

<div class="theme-info">
  主题 -
  <a class="theme-link" href="https://github.com/iissnan/hexo-theme-next">
    NexT.Pisces
  </a>
</div>

        

        
      </div>
    </footer>

    <div class="back-to-top">
      <i class="fa fa-arrow-up"></i>
    </div>
  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>









  



  
  <script type="text/javascript" src="/vendors/jquery/index.js?v=2.1.3"></script>

  
  <script type="text/javascript" src="/vendors/fastclick/lib/fastclick.min.js?v=1.0.6"></script>

  
  <script type="text/javascript" src="/vendors/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>

  
  <script type="text/javascript" src="/vendors/velocity/velocity.min.js?v=1.2.1"></script>

  
  <script type="text/javascript" src="/vendors/velocity/velocity.ui.min.js?v=1.2.1"></script>

  
  <script type="text/javascript" src="/vendors/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script>


  


  <script type="text/javascript" src="/js/src/utils.js?v=5.0.1"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=5.0.1"></script>



  
  


  <script type="text/javascript" src="/js/src/affix.js?v=5.0.1"></script>

  <script type="text/javascript" src="/js/src/schemes/pisces.js?v=5.0.1"></script>



  

  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=5.0.1"></script>



  

  
    
  

  <script type="text/javascript">
    var duoshuoQuery = {short_name:"kangarootao"};
    (function() {
      var ds = document.createElement('script');
      ds.type = 'text/javascript';ds.async = true;
      ds.id = 'duoshuo-script';
      ds.src = (document.location.protocol == 'https:' ? 'https:' : 'http:') + '//static.duoshuo.com/embed.js';
      ds.charset = 'UTF-8';
      (document.getElementsByTagName('head')[0]
      || document.getElementsByTagName('body')[0]).appendChild(ds);
    })();
  </script>

  
    
  





  
  
  

  

  

</body>
</html>
